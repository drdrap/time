<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Временная дилатация: γ(v) при v→c</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #101721;
      --ink: #e6eef7;
      --sub: #9fb3c8;
      --grid: #263244;
      --accent: #7dd3fc;
      --accent2: #22d3ee;
      --warn: #f43f5e;
      --ok: #34d399;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(120% 100% at 50% 0%, #0b1220 0%, var(--bg) 60%);
      color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
      line-height: 1.4;
    }
    .wrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: clamp(12px, 2vw, 24px);
      max-width: 1100px;
      margin: 0 auto;
    }
    header h1 { font-size: clamp(20px, 3vw, 28px); margin: 0 0 6px; }
    header p { margin: 0; color: var(--sub); }

    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(0,0,0,0.15));
      border: 1px solid #182231;
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.02);
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }
    @media (min-width: 720px) {
      .controls { grid-template-columns: 1.2fr 1fr 1fr 1fr; align-items: end; }
    }

    label { display: grid; gap: 6px; color: var(--sub); font-size: 14px; }
    input[type="range"] { width: 100%; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    select, input[type="range"], button {
      appearance: none;
      background: var(--panel);
      color: var(--ink);
      border: 1px solid #1c2a3a;
      border-radius: 10px;
      padding: 8px 10px;
      font: inherit;
    }
    button { cursor: pointer; }
    button:active { transform: translateY(1px); }

    .readout {
      display: grid;
      grid-template-columns: repeat(4, minmax(120px,1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .stat {
      background: var(--panel);
      border: 1px solid #1c2a3a;
      border-radius: 12px;
      padding: 10px;
      text-align: center;
    }
    .stat .k { color: var(--sub); font-size: 12px; }
    .stat .v { font-size: 18px; font-variant-numeric: tabular-nums; }

    canvas { width: 100%; height: 58vh; display: block; background: transparent; border-radius: 12px; }
    .legend { color: var(--sub); font-size: 13px; display: flex; gap: 18px; flex-wrap: wrap; }
    .chip { display: inline-flex; align-items: center; gap: 8px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--accent); box-shadow: 0 0 10px var(--accent); }
    .dot2 { background: var(--ok); box-shadow: 0 0 10px var(--ok);}    
    footer { color: var(--sub); font-size: 12px; }
    code { color: var(--accent2); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>График замедления времени при v → c</h1>
      <p>Модель: <code>γ(v) = 1 / √(1 − (v/c)²)</code>. Можно также смотреть скорость часов как <code>1/γ</code>. Ось X: β = v/c. Ось Y: выбранная метрика.</p>
    </header>

    <section class="panel controls">
      <label>
        β = v/c
        <input id="beta" type="range" min="0" max="0.99999" step="0.00001" value="0.7" />
      </label>
      <label>
        Метрика Y
        <select id="metric">
          <option value="gamma">γ (коэффициент дилатации, растёт до ∞)</option>
          <option value="inv">1/γ (скорость хода часов)</option>
        </select>
      </label>
      <label>
        Верхняя граница Y
        <select id="ymax">
          <option>5</option>
          <option selected>10</option>
          <option>25</option>
          <option>50</option>
          <option>100</option>
        </select>
      </label>
      <div class="row">
        <button id="play">▶ Старт</button>
        <button id="reset">⟲ Сброс</button>
        <label style="display:flex;align-items:center;gap:8px">
          <input id="grid" type="checkbox" checked /> Сетка
        </label>
      </div>
      <div class="readout">
        <div class="stat"><div class="k">β = v/c</div><div class="v" id="read_beta">0.70</div></div>
        <div class="stat"><div class="k">γ</div><div class="v" id="read_gamma">1.40</div></div>
        <div class="stat"><div class="k">1/γ (ход часов)</div><div class="v" id="read_invg">0.71</div></div>
        <div class="stat"><div class="k">Δt' = γ·Δt</div><div class="v" id="read_dt">1.40 Δt</div></div>
      </div>
    </section>

    <section class="panel">
      <canvas id="plot"></canvas>
      <div class="legend" style="margin-top:8px">
        <span class="chip"><span class="dot"></span> Кривая γ или 1/γ</span>
        <span class="chip"><span class="dot dot2"></span> Текущая точка (β)</span>
        <span>Пунктир: вертикальная асимптота при β→1</span>
      </div>
    </section>

    <footer>
      Построение происходит в физически корректной шкале β∈[0, 1). Для наглядности используется ограничение по Y и полупрозрачная зона возле β≈1.
    </footer>
  </div>

  <script>
    const $ = sel => document.querySelector(sel);
    const betaEl = $('#beta');
    const metricEl = $('#metric');
    const ymaxEl = $('#ymax');
    const gridEl = $('#grid');
    const playBtn = $('#play');
    const resetBtn = $('#reset');

    const readBeta = $('#read_beta');
    const readGamma = $('#read_gamma');
    const readInvG = $('#read_invg');
    const readDt = $('#read_dt');

    const canvas = $('#plot');
    const ctx = canvas.getContext('2d');

    let playing = false;
    let lastT = 0;

    function dpiResize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { width, height } = canvas.getBoundingClientRect();
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      draw();
    }

    window.addEventListener('resize', dpiResize);

    function gammaOf(beta) {
      if (beta >= 1) return Infinity;
      return 1 / Math.sqrt(1 - beta * beta);
    }

    function invGamma(beta) { return 1 / gammaOf(beta); }

    function fmt(x, d=2) {
      if (!isFinite(x)) return '∞';
      return x.toFixed(d);
    }

    function getCfg() {
      return {
        beta: parseFloat(betaEl.value),
        metric: metricEl.value, // 'gamma' or 'inv'
        yMax: parseFloat(ymaxEl.value),
        showGrid: gridEl.checked
      };
    }

    function axesRect() {
      const padL = 48, padR = 16, padT = 16, padB = 44;
      const w = canvas.clientWidth, h = canvas.clientHeight;
      return { x: padL, y: padT, w: w - padL - padR, h: h - padT - padB };
    }

    function xToPx(beta) {
      const r = axesRect();
      return r.x + beta * r.w; // β in [0,1)
    }

    function yToPx(y, yMax) {
      const r = axesRect();
      const clamped = Math.min(y, yMax);
      return r.y + r.h - (clamped / yMax) * r.h;
    }

    function drawGrid(yMax) {
      const r = axesRect();
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      ctx.lineWidth = 1;

      // verticals β: 0.0 .. 1.0 step 0.1
      for (let b = 0; b <= 1.00001; b += 0.1) {
        const x = xToPx(b);
        ctx.beginPath();
        ctx.moveTo(x, r.y);
        ctx.lineTo(x, r.y + r.h);
        ctx.stroke();
      }

      // horizontals Y: choose nice steps
      const steps = [1,2,5];
      let step = 1;
      while (yMax / step > 8) step *= 2.5; // 1→2.5→6.25→...
      const nice = step;
      for (let y = 0; y <= yMax + 1e-9; y += nice) {
        const py = yToPx(y, yMax);
        ctx.beginPath();
        ctx.moveTo(r.x, py);
        ctx.lineTo(r.x + r.w, py);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawAxes(yMax) {
      const r = axesRect();
      ctx.save();
      ctx.strokeStyle = '#35506e';
      ctx.lineWidth = 1.5;
      // X axis
      ctx.beginPath();
      ctx.moveTo(r.x, r.y + r.h);
      ctx.lineTo(r.x + r.w, r.y + r.h);
      ctx.stroke();
      // Y axis
      ctx.beginPath();
      ctx.moveTo(r.x, r.y);
      ctx.lineTo(r.x, r.y + r.h);
      ctx.stroke();

      ctx.fillStyle = '#9fb3c8';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      // X ticks β
      for (let b = 0; b <= 1.00001; b += 0.1) {
        const x = xToPx(b);
        ctx.beginPath();
        ctx.moveTo(x, r.y + r.h);
        ctx.lineTo(x, r.y + r.h + 6);
        ctx.stroke();
        ctx.fillText(b.toFixed(1), x, r.y + r.h + 8);
      }

      // Y ticks
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const yStep = (()=>{ let s=1; while (yMax/s>8) s*=2.5; return s; })();
      for (let y = 0; y <= yMax + 1e-9; y += yStep) {
        const py = yToPx(y, yMax);
        ctx.beginPath();
        ctx.moveTo(r.x - 6, py);
        ctx.lineTo(r.x, py);
        ctx.stroke();
        ctx.fillText(y.toString(), r.x - 8, py);
      }

      // labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText('β = v/c', r.x + r.w/2, r.y + r.h + 28);
      ctx.save();
      ctx.translate(16, r.y + r.h/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('γ  или  1/γ', 0, 0);
      ctx.restore();

      // vertical asymptote near β=1
      const ax = xToPx(1);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = '#6b7280';
      ctx.beginPath();
      ctx.moveTo(ax, r.y);
      ctx.lineTo(ax, r.y + r.h);
      ctx.stroke();
      ctx.setLineDash([]);

      // shade near β>0.97
      const shadeX = xToPx(0.97);
      const grad = ctx.createLinearGradient(shadeX, 0, ax, 0);
      grad.addColorStop(0, 'rgba(34,211,238,0.0)');
      grad.addColorStop(1, 'rgba(34,211,238,0.12)');
      ctx.fillStyle = grad;
      ctx.fillRect(shadeX, r.y, ax - shadeX, r.h);

      ctx.restore();
    }

    function drawCurve(metric, yMax) {
      const r = axesRect();
      const n = Math.max(400, Math.floor(r.w));
      ctx.save();
      ctx.lineWidth = 2;

      // gradient stroke
      const grad = ctx.createLinearGradient(r.x, r.y, r.x + r.w, r.y);
      grad.addColorStop(0, '#7dd3fc');
      grad.addColorStop(1, '#22d3ee');
      ctx.strokeStyle = grad;
      ctx.beginPath();

      const yVal = b => metric === 'gamma' ? gammaOf(b) : invGamma(b);

      for (let i = 0; i <= n; i++) {
        const b = i / n * 0.9999; // avoid Infinity at 1
        const y = yVal(b);
        const xpx = xToPx(b);
        const ypx = yToPx(y, yMax);
        if (i === 0) ctx.moveTo(xpx, ypx);
        else ctx.lineTo(xpx, ypx);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawMarker(beta, metric, yMax) {
      const y = metric === 'gamma' ? gammaOf(beta) : invGamma(beta);
      const xpx = xToPx(beta);
      const ypx = yToPx(y, yMax);

      // vertical line
      ctx.save();
      ctx.strokeStyle = '#34d399';
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(xpx, axesRect().y);
      ctx.lineTo(xpx, axesRect().y + axesRect().h);
      ctx.stroke();
      ctx.setLineDash([]);

      // dot
      ctx.fillStyle = '#34d399';
      ctx.shadowColor = '#34d399';
      ctx.shadowBlur = 16;
      ctx.beginPath();
      ctx.arc(xpx, ypx, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function draw() {
      const cfg = getCfg();
      const r = axesRect();
      // clear
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      if (cfg.showGrid) drawGrid(cfg.yMax);
      drawAxes(cfg.yMax);
      drawCurve(cfg.metric, cfg.yMax);
      drawMarker(cfg.beta, cfg.metric, cfg.yMax);

      // update readouts
      const g = gammaOf(cfg.beta);
      readBeta.textContent = cfg.beta.toFixed(5);
      readGamma.textContent = fmt(g, 5);
      readInvG.textContent = fmt(1 / g, 5);
      readDt.textContent = `${fmt(g, 3)} Δt`;
    }

    function animate(t) {
      if (!lastT) lastT = t;
      const dt = Math.min(50, t - lastT);
      lastT = t;
      if (playing) {
        // ease beta towards 0.9995
        const b = parseFloat(betaEl.value);
        const target = 0.9995;
        const speed = 0.0003 + 0.001 * (1 - b); // slower as we approach 1
        const next = Math.min(target, b + speed * dt / 16);
        betaEl.value = String(next);
        draw();
        if (next >= target - 1e-6) playing = false, playBtn.textContent = '▶ Старт';
      }
      requestAnimationFrame(animate);
    }

    // events
    [betaEl, metricEl, ymaxEl, gridEl].forEach(el => el.addEventListener('input', draw));
    playBtn.addEventListener('click', () => {
      playing = !playing;
      playBtn.textContent = playing ? '⏸ Пауза' : '▶ Старт';
    });
    resetBtn.addEventListener('click', () => {
      betaEl.value = '0.7';
      metricEl.value = 'gamma';
      ymaxEl.value = '10';
      gridEl.checked = true;
      playing = false;
      playBtn.textContent = '▶ Старт';
      draw();
    });

    // init
    dpiResize();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
